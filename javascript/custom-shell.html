<!--

  BrogueJS (https://github.com/freethenation)

  @freethenation (Richard Klafter, 2019)
  @lachesis      (Eric Swanson,    2019)
  @brturn        (Bryan Turner,    2026)

  Copyright (C) 2019 Richard Klafter

     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Affero General Public License for more details.

     You should have received a copy of the GNU Affero General Public License
     along with this program.  If not, see <http://www.gnu.org/licenses/>.

-->
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

    <!-- App title -->
    <title>BrogueCE v1.15.1-js</title>
    <meta name="application-name" content="BrogueCE v1.15.1-js" />
    <meta name="apple-mobile-web-app-title" content="BrogueCE v1.15.1-js" />

    <!-- Icon support -->
    <link rel="apple-touch-icon" type="image/png" sizes="256x256" href="brogue-icon-256.png" />
    <link rel="icon" type="image/png" sizes="256x256" href="brogue-icon-256.png" />
    <link rel="shortcut icon" href="favicon.ico" />
    <link rel="icon" type="image/vnd.microsoft.icon" href="favicon.ico" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link rel="icon" href="favicon.ico" />

    <!-- Web-app support -->
    <link rel="manifest" href="manifest.json" />
    <meta content="no-cache, no-store, must-revalidate" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <link rel="apple-touch-startup-image" href="brogue-title-screen.jpg" />

    <!-- Other meta tags -->
    <meta name="keywords" content="game,entertainment,rogue,roguelike" />
    <meta name="description" content="Brogue is a single-player strategy game set in the halls of a mysterious and randomly-generated dungeon. Retrieve the fabled Amulet of Yendor from the 26th level and escape with your life!" />

    <style>
      html, body {
        margin: 0;
        margin-top: 0;
        margin-bottom: 0;
        margin-left: 0;
        margin-right: 0;

        padding: 0;
        padding-top: 0;
        padding-bottom: 0;
        padding-left: 0;
        padding-right: 0;

        width: 100vw;
        height: 100vh;

        display: flex;
        justify-content: center;
        align-items: center;

        background: #111111;
        color: #888888;
        background-attachment: fixed;
        overflow: hidden;
      }
      div {
        margin: 0;
        padding: 0;
      }
      body a {
          color: #888888;
      }
      body a:hover {
          color: #6666cb;
      }
      #game-canvas {
          background: #111111;
          image-rendering: pixelated;
          touch-action: none;
          aspect-ratio: inherit;
      }
      .nav-bar > div {
        margin: 2px;  /* file manager list item padding */
        background-color: #6666cb;
      }
      span {
        height: 100%;
      }
      .list-item {
        display: flex;
        align-items: center;
        height: 2em;
      }
      .item-text {
        display: flex;
        align-items: center;
        height: 100%;
        padding-left: 0.5em;
      }
      .floating-div {
          position: fixed;
          top: 2em;
          left: 10%;
          width: 40%;
          height: 30%;
          overflow-y: auto;
          background-color: #333333;
          border: 1px solid black;
          padding: 10px;
          z-index: -1000;
          color: white;
      }
      #keyboard {
        background-color: #222222;
        padding: 0.25em 0.5em;
        border: 2px solid var(--input-border);
        border-radius: 4px;
        display: none;
      }
      #file-manager {
        display: flex;
        flex-direction: column;
        border: 2px solid var(--input-border);
        border-radius: 4px;
        z-index: 1000;
        visibility: hidden;
      }
      #file-mgr-title {
        display: flex;
        align-items: center;
      }
      #file-mgr-upload {
        display: none;
      }
      #file-input {
        background-color: #222222;
        padding: 0.25em 0.5em;
        border: 2px solid var(--input-border);
        border-radius: 4px;
      }
      img {
        background-color: #555555;
        padding: 0.1em 0.1em;
        border: 2px solid var(--input-border);
        border-radius: 4px;
        max-width: 1.5em;
        max-height: 1.5em;
        margin: 2px;
      }
      img:hover {
        background-color: #777777;
      }
      #button-bar {
          position: absolute;
          right: -2.5em;
          top: 10%;
          width: 3em;
          min-height: 11em;
          transition: top 0.5s ease;
          box-sizing: border-box;
          z-index: 500;

          background-color: #555555;
          padding: 0.1em 0.1em;
          border: 2px solid var(--input-border);
          border-radius: 4px;
          margin: 2px;

          padding-left: 0.75em;
      }
      #button-bar.open {
          right: 0;
      }
      #about {
          position: fixed;
          top: 10%;
          left: 20%;
          width: 50%;
          height: 50%;
          overflow-y: auto;
          background-color: #333333;
          border: 1px solid black;
          padding: 10px;
          z-index: 900;
          visibility: hidden;
          color: white;
      }
      #about a {
        color: #4c89c2
      }
      #escape {
        position: absolute;
        top: 0;
        left: 0;
        width: 16em;
        max-height: none;
        max-width: none;
        z-index: 100;
        visibility: hidden;
      }
      #dirpad {
        position: absolute;
        visibility: hidden;
        bottom: 3em;
        left: 3em;
        width: 2in;
        height: 2in;
        max-width: none;
        max-height: none;
        z-index: 90;
        background-color: transparent;
      }

      /* Wrap it in a @supports rule so it only takes effect on devices that understand this */
      @supports (padding: env(safe-area-inset-top)) {
        /* This is for PWA (on iOS), so that the status bar has a transparent yet blurry background. */
        body::before {
          content: '';
          z-index: 2; /* necessary to be above <audio> elements */
          position: fixed; /* position it fixed to it stays put at the top */
          top: 0;
          left: 0;
          right: 0;
          height: env(safe-area-inset-top); /* i.e. the exact height of the status bar */
          backdrop-filter: blur(10px);
          /* Fully blur the top half, then up to 0.7 blur-opacity/strength for the next quarter, and at last, go from 0.7 to full transparent (i.e. no blur) at the very bottom. */
          mask: linear-gradient(to bottom, black, black 50%, rgba(0, 0, 0, 0.7) 75%, rgba(0, 0, 0, 0) 100%);
        }
      }
    </style>
    <script>
      // Service worker registration for offline web app support
      let serviceWorker = null;
      const registerServiceWorker = () => {
        if (serviceWorker !== null) return;
        serviceWorker = false; // Arbitrary
        if (!('serviceWorker' in navigator)) return;
        navigator.serviceWorker.register('sw.js')
          .then(registration => {
            serviceWorker = registration;
            console.log('service worker registered successfully:', registration);

            // Check to make sure background sync is supported.
            if ('SyncManager' in window) {
              try {
                registration.sync.register('background-sync')
                  .then( e => {
                    console.log("Background Sync registration successful.", e);
                  });
              } catch (e) {
                console.log("Background Sync registration failed.", e)
              }
            }
          })
          .catch(error => {
            console.log('service worker registration failed:', error);
          });
      }
      document.addEventListener('DOMContentLoaded', registerServiceWorker );
      window.addEventListener('load', registerServiceWorker);
    </script>
    <script type="text/javascript">

      // -------------------------------------------------
      // Constants
      // -------------------------------------------------

      const ongoingTouches = new Map(); // Mapping from the pointerId to the current finger position
      const isMacOS = navigator.platform.match("Mac");
      const BROGUE_FONT = 'BrogueFont';
      const myFont = new FontFace(BROGUE_FONT, 'url(BrogueCE.ttf)');
      const MIN_EVENT_MS = 100; // TODO: Adjust this dynamically to match device performance
      const FONT_HEIGHT_SCALE = 1.3;
      const STORE_NAME = "FILE_DATA";
      const BROGUE_PATH = "/brogue/";
      const CONSOLE_HEIGHT = 34;
      const CONSOLE_WIDTH = 100;
      const CELL_ASPECT_RATIO = 19/10;
      const eventTypes = {
          KEYSTROKE:0,
          MOUSE_UP:1,
          MOUSE_DOWN:2,
          RIGHT_MOUSE_DOWN:3,
          RIGHT_MOUSE_UP:4,
          MOUSE_ENTERED_CELL:5
      }

      // -------------------------------------------------
      // Globals
      // -------------------------------------------------

      let ctx, ctxWidth, ctxHeight;
      let cellWidth, cellHeight, cellOffset, canvas;
      let halfWidth, wallWidth, wallHeight, fontSize;
      let wallScaleX, wallScaleY;
      let FONT_NAME = "monospace";
      let lastMouseCell = [-1,-1];
      let lastMoveEvent = 0;
      let firstTouch = null;
      let db = null;
      let gamepad = null;
      let devicePixelRatio = window.devicePixelRatio || 1;

      // -------------------------------------------------
      // Rendering
      // -------------------------------------------------

      const status = (str) => {
        document.getElementById("status").innerText = str;
      }

      const plotChar = tile => {
        let [char, x, y, fr, fg, fb, br, bg, bb] = tile;
        window.allChars[(x<<8)+y] = tile; // Store a buffer of all tiles for when the window gets resized
        x = Math.floor(x*cellWidth);
        y = Math.floor(y*cellHeight);

        ctx.save();
        ctx.beginPath();
        ctx.rect(x,y,cellWidth,cellHeight);
        ctx.clip();

        ctx.fillStyle = `rgb(${br/100*255|0}, ${bg/100*255|0}, ${bb/100*255|0})`;
        ctx.fillRect(x,y,cellWidth,cellHeight);
        ctx.fillStyle = `rgb(${fr/100*255|0}, ${fg/100*255|0}, ${fb/100*255|0})`;

        // Center text in cell
        x += halfWidth;

        // Graphics mode tiles that look bad if there are gaps between them
        if ((char == 0x4051 || char == 0x4064 || char == 0x4041 || char == 0x4002)) {
          const newX = Math.ceil(x/wallScaleX);   // Adjust location based on scale
          const newY = Math.floor((y-1)/wallScaleY);
          ctx.scale(wallScaleX, wallScaleY);      // Stretch graphics to fit cell
          ctx.fillText(String.fromCharCode(char), newX, newY);
        } else {
          ctx.fillText(String.fromCharCode(char), x, y + cellOffset);
        }
        ctx.restore();
      }

      const plotAllChars = () => {
        Object.values(window.allChars).forEach(plotChar);
      }

      // -------------------------------------------------
      // Mouse & Touch Events
      // -------------------------------------------------

      const getMousePos = (evt) => {
          const rect = canvas.getBoundingClientRect(); // abs. size of element
          const actualWidth = Math.min(rect.height*(canvas.width/canvas.height), rect.width)|0; //object-fit means the canvas ele will be scaled proportionally
          const actualHeight = Math.min(rect.width*(canvas.height/canvas.width), rect.height)|0; //so calculate actual width and height
          const scale = canvas.width/actualWidth;
          const offsetX = (rect.width-actualWidth)/2;
          const offsetY = (rect.height-actualHeight)/2;
          const x = (evt.clientX - rect.left) - offsetX;
          const y = (evt.clientY - rect.top) - offsetY;
          if (x<0 || x>actualWidth)  return null; // ignore if object-fit causes us to be outside actual canvas
          if (y<0 || y>actualHeight) return null; // ignore if object-fit causes us to be outside actual canvas
          const pix = [x*scale/devicePixelRatio, y*scale/devicePixelRatio]; // in pixels
          const pos = [(pix[0]/cellWidth)|0, (pix[1]/cellHeight)|0]; // in cells
          return pos;
      }

      const onMouseMove = (e) => {
        // Throttle mouse move events
        const now = Date.now();
        if (now < lastMoveEvent + MIN_EVENT_MS) return;
        lastMoveEvent = now;

        const pos = getMousePos(e);
        if (!pos) return;
        if (lastMouseCell[0]===pos[0] && lastMouseCell[1]===pos[1]) return; //cell did not change...bail
        lastMouseCell = pos;
        const EVENT = [ eventTypes.MOUSE_ENTERED_CELL, pos[0], pos[1], e.ctrlKey?1:0, e.shiftKey?1:0 ];
        window.keyOrMouseEvents.push(EVENT);
      }

      const onMouseDown = (e) => {
          const pos = getMousePos(e);
          if (!pos) return;
          const EVENT = [ e.button===0?eventTypes.MOUSE_DOWN:eventTypes.RIGHT_MOUSE_DOWN, pos[0], pos[1], e.ctrlKey?1:0, e.shiftKey?1:0 ];
          window.keyOrMouseEvents.push(EVENT);
          document.getElementById('button-bar').classList.remove("open");
          document.getElementById('escape').style.visibility = "hidden";
      }

      const onMouseUp = (e) => {
          const pos = getMousePos(e);
          if(!pos) return;
          const EVENT = [ e.button===0?eventTypes.MOUSE_UP:eventTypes.RIGHT_MOUSE_UP, pos[0], pos[1], e.ctrlKey?1:0, e.shiftKey?1:0 ];
          window.keyOrMouseEvents.push(EVENT);
      }

      const sendTouchAsMouseEvent = (event) => {
        if (event.touches.length > 1) return;
        if (event.type === "touchend" && event.touches.length > 0) return;

        // Make it look like a mouse event
        const touch = event.changedTouches[0];
        const e = {
          clientX: touch.clientX,
          clientY: touch.clientY,
          ctrlKey: event.ctrlKey,
          shiftKey: event.shiftKey,
          button: 0,
        }

        switch (event.type) {
          case "touchstart": return onMouseDown(e);
          case "touchmove":  return onMouseMove(e);
          case "touchend":   return onMouseUp(e);
          default: return;
        }
      }

      const handleTouchStart = (event) => {
        event.preventDefault();

        // Manage each simultaneous touch
        for (const changedTouch of event.changedTouches) {
          const touch = {
            pageX: changedTouch.pageX,
            pageY: changedTouch.pageY,
            id: changedTouch.identifier,
          };
          ongoingTouches.set(changedTouch.identifier, touch);

          // Record or update the first touch
          if (firstTouch === null || firstTouch.id === changedTouch.identifier) {
            firstTouch = touch;
            sendTouchAsMouseEvent(event);
          }
        }
      }

      const handleTouchMove = (event) => {
        event.preventDefault();

        for (const changedTouch of event.changedTouches) {
          const touch = ongoingTouches.get(changedTouch.identifier);
          if (!touch) {
            continue;
          }
          touch.pageX = changedTouch.pageX;
          touch.pageY = changedTouch.pageY;

          // Update firstTouch
          if (firstTouch !== null && firstTouch.id === changedTouch.identifier) {
            sendTouchAsMouseEvent(event);
          }
        }
      }

      const handleTouchEnd = (event) => {
        event.preventDefault();

        for (const changedTouch of event.changedTouches) {
          if (!ongoingTouches.has(changedTouch.identifier)) {
            continue;
          }
          ongoingTouches.delete(changedTouch.identifier);

          // Update firstTouch
          if (firstTouch !== null && firstTouch.id === changedTouch.identifier) {
            sendTouchAsMouseEvent(event);
            firstTouch = null;
          }
        }

        // Failsafe, reset firstTouch when all touches end
        if (event.touches.length == 0) {
          firstTouch = null;
        }
      }

      const handleTouchCancel = (event) => {
        event.preventDefault();

        for (const changedTouch of event.changedTouches) {
          if (!ongoingTouches.has(changedTouch.identifier)) {
            continue;
          }
          ongoingTouches.delete(changedTouch.identifier);
          if (firstTouch !== null && firstTouch.id === changedTouch.identifier) {
            sendTouchAsMouseEvent(event);
            firstTouch = null;
          }
        }
      }

      const pressed = (gp,idx) => {
        const button = gp.buttons[idx];
        return button.pressed || button.touched || button.value > 0.01;
      }

      let delay = 10; // At 60 FPS, this is 6 keypresses per sec
      let delayCountdown = 0;
      const handleGamepad = () => {
        // Called regularly to translate gamepad events into keystrokes
        if (!gamepad) return;
        window.requestAnimationFrame(handleGamepad);

        // Delay key presses
        delayCountdown -= 1;
        if (delayCountdown > 0) return;

        /*
        Standard Game-Pad:
        https://w3c.github.io/gamepad/#remapping

             06                           07    <-- Bottom trigger buttons
             04                           05    <-- Top trigger buttons
                           16                   <-- Middle console button

         Left D-Pad                   Right D-Pad
        |    12    | select   start  |    03    |
        | 14    15 |   08      09    | 02    01 |
        |    13    |                 |    00    |

             10                           11     <-- Press analog sticks

        Left Joystick
          axes[0] -1 (left) .. +1 (right)
          axes[1] -1 (up)   .. +1 (down)

        Right Joystick
          axes[2] -1 (left) .. +1 (right)
          axes[3] -1 (up)   .. +1 (down)
        */

        const gp = navigator.getGamepads()[gamepad.index];
        const EVENT = [eventTypes.KEYSTROKE, 0, 0, 0/* ctrlKey */, 0 /* shiftKey */];
        const dpadRight = "789"+  // Use number pad to avoid answering Y/N while traveling
                          "456"+
                          "123";

        const dpadLeft  = "789"+
                          "456"+
                          "123";

        const otherKeys = "s.td\u{1b}\u{0d}.."; // Left-Top-Trigger, Right-Top-Trigger, Left-Bottom-Trigger, Right-Bottom-Trigger, Select, Start, Left-Alog-Press, Right-Alog-Press

        // Right D-Pad (assume 8-way)
        const rightY = (pressed(gp,3) ? 0x100 : (pressed(gp,0) ? 0x106 : 3));
        const rightX = (pressed(gp,2) ? 0x100 : (pressed(gp,1) ? 0x102 : 1));
        const rightKey = rightY + rightX;
        if (rightKey >= 0x100) {
          EVENT[1] = dpadRight.charCodeAt(rightKey & 0xFF);
          window.keyOrMouseEvents.push(EVENT);
          delayCountdown = delay;
          return;
        }

        // Left D-Pad (assume 8-way)
        const leftY = (pressed(gp,12) ? 0x100 : (pressed(gp,13) ? 0x106 : 3));
        const leftX = (pressed(gp,14) ? 0x100 : (pressed(gp,15) ? 0x102 : 1));
        const leftKey = leftY + leftX;
        if (leftKey >= 0x100) {
          EVENT[1] = dpadLeft.charCodeAt(leftKey & 0xFF);
          window.keyOrMouseEvents.push(EVENT);
          delayCountdown = delay;
          return;
        }

        // Right joystick
        const BIAS = 1.2;
        if (gp.axes.length > 3) {
          const keyIdx = Math.floor(gp.axes[3]+BIAS)*3 + Math.floor(gp.axes[2]+BIAS);
          if (keyIdx != 4) {
            EVENT[1] = dpadLeft.charCodeAt(keyIdx);
            window.keyOrMouseEvents.push(EVENT);
            delayCountdown = delay;
            return;
          }
        }

        // Left joystick
        if (gp.axes.length > 1) {
          const keyIdx = Math.floor(gp.axes[1]+BIAS)*3 + Math.floor(gp.axes[0]+BIAS);
          if (keyIdx != 4) {
            EVENT[1] = dpadLeft.charCodeAt(keyIdx);
            window.keyOrMouseEvents.push(EVENT);
            delayCountdown = delay;
            return;
          }
        }

        // Other buttons
        const LOW_IDX = 4;
        const others = gp.buttons.map((b,i) => (i >= LOW_IDX && pressed(gp,i)) ? i-LOW_IDX : null ).filter(Boolean);
        if (others.length > 0) {
            EVENT[1] = otherKeys.charCodeAt(others[0]); // Take the first button in the list
            window.keyOrMouseEvents.push(EVENT);
            delayCountdown = delay;
            return;
        }
      }

      // -------------------------------------------------
      // Key Events
      // -------------------------------------------------

      const KEY_MAP = {
          ArrowUp: 63232,
          ArrowLeft: 63234,
          ArrowDown: 63233,
          ArrowRight: 63235,
          PageUp:63276,
          PageDown:63277,
          Escape:27,
          Return:13,
          Enter:10,
          Delete:127,
          Backspace:127,
          Tab:9,
      }

      const ESCAPE_KEY_EVENT = [eventTypes.KEYSTROKE,27,0,0,0];
      const allCtrlKeys = "hjklyubn78946123sxA<>"; // Keys that behave differently when a modifier is used
      const onKeydown = (e) => {
          // Override browser key bindings where possible
          const modkey = isMacOS ? e.metaKey : e.ctrlKey;
          if (   e.code == "NumpadDivide"
              || e.code == "Slash"
              || e.code == "Quote"
              || (modkey && allCtrlKeys.includes(e.key[0]))) {
            e.preventDefault();
          }
          const key = (e.key.length > 1) ? KEY_MAP[e.key] : e.key.charCodeAt(0);
          if (key === undefined) return;
          const EVENT = [eventTypes.KEYSTROKE, key, 0, e.ctrlKey?1:0, e.shiftKey?1:0];
          window.keyOrMouseEvents.push(EVENT);
      }

      // -------------------------------------------------
      // Initialization & Resizing
      // -------------------------------------------------

      const onRequestFullscreen = () => {
          const ele = document.getElementById('content');
          if (ele) ele.requestFullscreen();
      }

      const setupRetinaCanvas = (canvas, width, height) => {
          const ctx = canvas.getContext('2d');

          // Get the CSS-determined size of the canvas
          // const rect = canvas.getBoundingClientRect();
          const cssWidth  = Math.floor(width);
          const cssHeight = Math.floor(height);

          // Set the actual canvas buffer size to the high DPI dimensions
          canvas.width  = Math.floor(cssWidth  * devicePixelRatio);
          canvas.height = Math.floor(cssHeight * devicePixelRatio);

          // Scale the context so drawing operations use the CSS pixel coordinates
          ctx.scale(devicePixelRatio, devicePixelRatio);

          // Set the CSS dimensions back to the original intended size
          canvas.style.width  = cssWidth  + 'px';
          canvas.style.height = cssHeight + 'px';
          return ctx;
      }

      const roundTo = (num,sz) => {
        return Math.floor(num * sz) / sz;
      }

      const measureText = (cellAspect) => {
        // Special: Measure the BrogueCE.ttf graphic wall tile
        const wallMeasure = ctx.measureText("\u{4051}");
        wallWidth  = Math.floor(wallMeasure.width)-1; // Stretch the wall slightly so there are no gaps
        wallHeight = Math.floor(wallMeasure.actualBoundingBoxAscent + wallMeasure.actualBoundingBoxDescent)-1;

        // Measure text chars
        const measure = ctx.measureText("jf"); // Tallest and lowest chars
        const width   = Math.floor(measure.width/2);
        const height  = Math.floor(measure.actualBoundingBoxAscent + measure.actualBoundingBoxDescent) + 2; // Make the font slightly taller when measuring

        cellHeight = Math.max(wallHeight, height);
        cellWidth  = wallWidth;
      }

      const findFontThatFits = (maxWidth, maxHeight) => {
        // Find proper font size
        const cellAspect = Math.floor(maxHeight / maxWidth);
        let size = 7;
        const FONT_MULT = 10; // Micro-step font sizes
        const MIN_FONT_SIZE = 7;
        const MAX_FONT_SIZE = 80;
        for (let i = MIN_FONT_SIZE*FONT_MULT; i <= MAX_FONT_SIZE*FONT_MULT; i++) {
            size = i/FONT_MULT;
            ctx.font = size+'px '+FONT_NAME;
            measureText(cellAspect);
            if (cellWidth >= maxWidth || cellHeight >= maxHeight) {
                size = (i-1)/FONT_MULT;
                ctx.font = size+'px '+FONT_NAME;
                measureText(cellAspect);
                break;
            }
        }

        // Vertical centering
        cellOffset = Math.floor((maxHeight - cellHeight)/2) - 1; // Shift characters up 1 pixel so they don't get clipped off
        return size;
      }

      const resizeCanvas = () => {
        const content = document.getElementById("content");
        canvas = document.getElementById('game-canvas');

        // We have to do a two-step dance when resizing:
        // - Set the content size to fill the screen
        // - Resize the canvas based on the content size
        // - Set the content size to be the size of the canvas so it centers properly
        content.style.width  = "100vw";
        content.style.height = "100vh";

        const maxCellWidth  = Math.floor(content.clientWidth  / CONSOLE_WIDTH);
        const maxCellHeight = Math.floor(content.clientHeight / CONSOLE_HEIGHT);

        // Adjust DPR
        const urlParams = new URLSearchParams(window.location.search);
        const dpr = urlParams.get('dpr');
        if (dpr) devicePixelRatio = Number(dpr);
        else devicePixelRatio = window.devicePixelRatio || 1;

        ctx = canvas.getContext("2d");
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.textRendering = 'pixelated';
        ctx.imageSmoothingEnabled = false;

        // Find proper font size
        fontSize = findFontThatFits(maxCellWidth, maxCellHeight);

        cellWidth  = maxCellWidth;
        cellHeight = maxCellHeight;
        wallScaleX = cellWidth/wallWidth;
        wallScaleY = cellHeight/wallHeight;
        halfWidth  = Math.floor(cellWidth/2);
        ctxWidth   = cellWidth  * CONSOLE_WIDTH;
        ctxHeight  = cellHeight * CONSOLE_HEIGHT;

        // Get context for the resized canvas
        ctx = setupRetinaCanvas(canvas, ctxWidth, ctxHeight);
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.textRendering = 'pixelated';
        ctx.imageSmoothingEnabled = false;
        ctx.font = fontSize+'px '+FONT_NAME;

        // Set the content tightly around the canvas so it centers properly
        content.style.width  = ctxWidth;
        content.style.height = ctxHeight;

        // Redraw the canvas
        plotAllChars();
      }

      const getEl = (id) => document.getElementById(id);
      const addEvent = (id,evt,fn,opt) => getEl(id).addEventListener(evt,fn,opt);

      const initializeBrogueFrame = () => {
        resizeCanvas(FONT_NAME);

        // Register event handlers
        window.addEventListener('resize', () => resizeCanvas() );
        window.addEventListener('keydown', onKeydown, { capture: true });
        window.addEventListener('gamepadconnected', (e) => { gamepad = e.gamepad; window.requestAnimationFrame(handleGamepad); });
        window.addEventListener('gamepaddisconnected', (e) => { gamepad = null; });

        addEvent('fullscreen',      'click',  onRequestFullscreen, false);
        addEvent('files',           'click',  onRequestFiles, false);
        addEvent('file-input',      "change", handleFiles);
        addEvent('keyboard-icon',   "click",  (ele) => { ele.target.value = ""; getEl('keyboard').style.display = "block"; getEl('keyboard').focus(); getEl('escape').style.visibility = "visible"; });
        addEvent('keyboard',        "blur",   (ele) => { ele.target.value = ""; ele.target.style.display = "none"; getEl('button-bar').classList.remove("open"); });
        addEvent('escape',          "click",  (ele) => { window.keyOrMouseEvents.push(ESCAPE_KEY_EVENT); ele.target.style.visibility = "hidden"; });
        addEvent('file-mgr-close',  'click',  ()    => { getEl('file-manager').style.visibility = "hidden"; }, false);
        addEvent('info',            'click',  ()    => { getEl('about').style.visibility = "visible"; }, false);
        addEvent('about',           'click',  ()    => { getEl('about').style.visibility = "hidden"; }, false);
        addEvent('button-bar',      'click',  (ele) => { ele.target.classList.add("open"); }, false);
        addEvent('upload',          'click',  (ele) => { ele.target.style.display = "none"; getEl('file-mgr-upload').style.display = "block"; }, false);
        addEvent('content',         "fullscreenchange", resizeCanvas );
        addEvent('dirs',            "click",  (ele) => { const dirs = getEl("dirpad"); dirs.style.visibility = (dirs.style.visibility == "visible") ? "hidden" : "visible"; } );

        // Auto-save when user leaves the page or app
        document.addEventListener("visibilitychange", () => {
          if (document.hidden || document.visibilityState === "hidden") {
            if (Module && Module._saveState) {
              Module._saveState();
            }
          } else {
            // Restore last state?
          }
        });

        // Mouse & Touch Events
        canvas = document.getElementById('game-canvas');
        canvas.addEventListener('mousedown',   onMouseDown, false);
        canvas.addEventListener('mouseup',     onMouseUp,   false);
        canvas.addEventListener('mousemove',   onMouseMove, false);

        canvas.addEventListener('touchstart',  handleTouchStart,  false);
        canvas.addEventListener('touchend',    handleTouchEnd,    false);
        canvas.addEventListener('touchmove',   handleTouchMove,   false);
        canvas.addEventListener('touchcancel', handleTouchCancel, false);

        addEvent("dirpad", "click", (event) => {
          event.preventDefault();
          const x = Math.floor(3*event.offsetX/event.target.width);
          const y = Math.floor(3*event.offsetY/event.target.height);
          const EVENT = [eventTypes.KEYSTROKE,0,0,0,0];
          const keys  = "789"+
                        "456"+
                        "123";
          EVENT[1] = keys.charCodeAt(y*3+x);
          window.keyOrMouseEvents.push(EVENT);
        }, false);
      }

      // Page initialization
      window.keyOrMouseEvents = []; // Shared with C code for event queue
      window.plotChars = {}; // Shared with C code for graphics update queue
      window.allChars = {}; // For redrawing the window on resize, etc.

      // Load custom font
      document.addEventListener('DOMContentLoaded', function() {
        myFont.load().then(font => {
          document.fonts.add(font); // Add font to the document's font list
          FONT_NAME = BROGUE_FONT;
          initializeBrogueFrame();
        }).catch( e => {
          FONT_NAME = "monospace";
          initializeBrogueFrame();
        });
      });

      // -------------------------------------------------
      // File Manager
      // -------------------------------------------------

      const downloadFile = (uint8Array, filename, contentType) => {
        const blob = new Blob([uint8Array], { type: contentType });
        const exportUrl = URL.createObjectURL(blob);
        const a = document.createElement("a");
        document.body.appendChild(a); // Append link to body to ensure it's clickable in all browsers

        a.href = exportUrl;
        a.download = filename; // The 'download' attribute suggests a filename
        a.target = "_self"; // Open in the same tab
        a.click();

        document.body.removeChild(a);
        URL.revokeObjectURL(exportUrl);
      }

      const requestFileForDownload = (fileName) => {
        const transaction = db.transaction([STORE_NAME], "readonly");
        const objectStore = transaction.objectStore(STORE_NAME);
        const request = objectStore.get(BROGUE_PATH+fileName);
        request.onerror = (event) => {
          console.log("ERROR:",event)
        };
        request.onsuccess = (event) => {
          downloadFile(request.result.contents, fileName, "text/plain"); 
        };
      }

      const requestDeleteFile = (fileName, ele) => {
        const transaction = db.transaction([STORE_NAME], "readwrite");
        const objectStore = transaction.objectStore(STORE_NAME);
        const request = objectStore.delete(BROGUE_PATH+fileName);
        request.onerror = (event) => {
          console.log("ERROR:",event)
        };
        request.onsuccess = (event) => {
          ele.parentNode.removeChild(ele);
        };
      }

      const requestWriteFile = (fileName, fileData) => {
        const transaction = db.transaction([STORE_NAME], "readwrite");
        const objectStore = transaction.objectStore(STORE_NAME);

        const newFile = {
          contents: new Uint8Array(fileData),
          mode: 0o100666,
          timestamp: new Date(),
        };
        const request = objectStore.add(newFile, BROGUE_PATH+fileName);
        request.onsuccess = (event) => {
          console.log("Data added successfully", event.target.result);
          const FILES = document.getElementById("file-list");
          addFileListItem(FILES,fileName);
          document.getElementById("file-mgr-upload").innerHTML = "<hr/>Reload page to make this file visible to BrogueJS.";
        };
        request.onerror = (event) => {
          document.getElementById("file-mgr-upload").innerHTML = "<hr/>ERROR - " + event.target.error;
        };
      }

      const addFileListItem = (FILES, fileName) => {
        fileName = fileName.replaceAll(BROGUE_PATH,"");
        const a = document.createElement("div");
        a.className = "list-item";

        const del = document.createElement("img");
        del.src = "delete.svg";
        del.className = "delete";
        del.addEventListener("click",() => requestDeleteFile(fileName, a));
        a.appendChild(del)

        const save = document.createElement("img");
        save.src = "download.svg";
        save.className = "download";
        save.addEventListener("click",() => requestFileForDownload(fileName));
        a.appendChild(save);

        const txt = document.createElement("span");
        txt.className = "item-text";
        txt.textContent = fileName;
        a.appendChild(txt)
        FILES.appendChild(a); // Append link to body to ensure it's clickable in all browsers
      }

      const listAllObjects = () => {
        const transaction = db.transaction([STORE_NAME], "readonly");
        const objectStore = transaction.objectStore(STORE_NAME);
        const allKeysReq = objectStore.getAllKeys();
        allKeysReq.onsuccess = function(event) {
          const allKeys = event.target.result;
          const FILES = document.getElementById("file-list");
          FILES.innerHTML = ""; // Delete existing file list
          allKeys.forEach(key => {
            addFileListItem(FILES, key);
          });
        };

        allKeysReq.onerror = function(event) {
          console.error("Error retrieving all objects:", event.target.error);
        };

        // Optional: monitor the transaction completion
        transaction.oncomplete = function() {
          console.log("Transaction completed.");
        };
      }

      // IndexedDB
      const readDatabase = () => {
        // Let us open our database
        const request = window.indexedDB.open("/brogue");
        request.onerror = (event) => {
          console.error("Why didn't you allow my web app to use IndexedDB?!");
        };
        request.onsuccess = (event) => {
          db = event.target.result;
          db.onerror = (event) => {
            // Generic error handler for all errors targeted at this database's requests!
            console.error(`Database error: ${event.target.error?.message}`);
          };

          listAllObjects();
        };
      }

      const handleFiles = (event) => {
        const selectedFiles = event.target.files; // This is a FileList object

        if (selectedFiles && selectedFiles.length > 0) {
          const firstFile = selectedFiles[0];
          const reader = new FileReader();

          // Define what to do when the file is loaded
          reader.onload = function(event) {
            const fileContent = event.target.result;
            console.log('File content (as text):', fileContent);
            requestWriteFile(firstFile.name, fileContent);
          };

          // Read the file content
          reader.readAsArrayBuffer(firstFile);
        }
      }

      const onRequestFiles = () => {
          readDatabase();
          document.getElementById('file-manager').style.visibility = "visible";
      }

      // -------------------------------------------------
      // Brogue Weekly Contest Seed
      // -------------------------------------------------

      const getMostRecentTuesday = () => {
        const today = new Date();
        const todayDayOfWeek = today.getDay(); // 0 (Sunday) to 6 (Saturday)
        const TUESDAY_DAY_OF_WEEK = 2; // Tuesday is 2

        // Calculate the difference in days.
        // The expression handles cases where today is Tuesday (diff is 0) or earlier in the week than Tuesday.
        const daysToSubtract = (todayDayOfWeek - TUESDAY_DAY_OF_WEEK + 7) % 7;
        const mostRecentTuesday = new Date(today);
        mostRecentTuesday.setDate(today.getDate() - daysToSubtract);

        // Get year, month, and day components
        const year = mostRecentTuesday.getFullYear();
        const month = (mostRecentTuesday.getMonth() + 1).toString().padStart(2, '0'); // Months are 0-indexed
        const day = mostRecentTuesday.getDate().toString().padStart(2, '0');
        return `${year}${month}${day}`;
      }
    </script>
  </head>
    <body oncontextmenu="return false;">
      <div id="content">
        <div id="nav-bar">
          <div id="button-bar">
            <span style="font-size: x-small;">260224</span>
            <img src="fullscreen.svg" id="fullscreen"    title="Fulscreen"/>
            <img src="dir-pad.svg"    id="dirs"          title="Direction Pad"/>
            <img src="files.svg"      id="files"         title="File manager"/>
            <img src="keyboard.svg"   id="keyboard-icon" title="Open keyboard (for tablets)"/>
            <img src="info.svg"       id="info"          title="About BrogueJS"/>
            <a href="https://github.com/brturn/BrogueCE/issues" target="_blank" rel="noopener noreferrer" title="Report an issue"><img src="bugs.svg"/></a>
            <div><input type="text" id="keyboard" size="2" placeholder="Keyboard"/></div>
          </div>
          <div id="about">
            <img src="close.svg"/> <b>BrogueJS - Brogue in the browser!</b>
            <p><a href="https://github.com/brturn" target="_blank" rel="noopener noreferrer">Bryan Turner, 2026</a></p>

            <p>Please report any issues with this beta-test version to <a href="https://github.com/brturn/BrogueCE/issues">Bryan's issues list</a>.</p>

            <p>This is an updated and improved version of the original
              <a href="https://github.com/freethenation/broguejs" target="_blank" rel="noopener noreferrer">BrogueJS</a>, full credit goes to
              <a href="https://github.com/freethenation"          target="_blank" rel="noopener noreferrer">Richard Klafter</a> and
              <a href="https://github.com/lachesis"               target="_blank" rel="noopener noreferrer">Eric Swanson</a>.</p>

            <p>This version of Brogue is based on
              <a href="https://github.com/tmewett/BrogueCE" target="_blank" rel="noopener noreferrer">BrogueCE</a> (community edition), led by
              <a href="https://github.com/tmewett"          target="_blank" rel="noopener noreferrer">Tom Mewett</a> with support from
              <a href="https://github.com/flend"            target="_blank" rel="noopener noreferrer">Tom Ford</a> and
              <a href="https://github.com/zenzombie"        target="_blank" rel="noopener noreferrer">Brandon Groom</a>.</p>

            <p>Brogue was created by <a href="http://sites.google.com/site/broguegame/" target="_blank" rel="noopener noreferrer">Brian Walker</a> (aka Pender).</p>

            <p>Graphic tiles are from the iOS port,
              <a href="https://github.com/btaylor84/iBrogueCE" target="_blank" rel="noopener noreferrer">iBrogueCE</a>, credit goes to
              <a href="https://github.com/sethhoward"          target="_blank" rel="noopener noreferrer">Seth Howard</a> and
              <a href="https://github.com/btaylor84"           target="_blank" rel="noopener noreferrer">Robert Taylor</a>.</p>

            <p>Improvements include:</p>
            <ul>
            <li>Updated to BrogueCE v1.15.1</li>
            <li>Uses the same font and graphics as the iOS port</li>
            <li>Supports high-dpi (retina) displays</li>
            <li>Sharp graphics, no image stretching</li>
            <li>Touch support for tablets (tested on iPad and iPhone)</li>
            <li>File manager for uploading, downloading, and deleting the save games and recordings</li>
            <li>Files are compatible with other BrogueCE platforms, so you can move files between devices to continue the adventure</li>
            <li>URL parameters supported for seed, graphics, mode, etc.  Allowing easy bookmarking and sharing experiences</li>
            <li>Keyboard request for tablet support</li>
            <li>Offline and webapp support for native app-like interface</li>
            </ul>

            <p>BrogueJS has been tested working on:</p>
            <ul>
            <li>MacBook Pro M4, Mac OS 26.2: Safari, Firefox, Chrome</li>
            <li>iPad Pro Gen 3, iOS 26.3, Safari</li>
            <li>iPhone 14 Pro, iOS 26.2, Safari</li>
            </ul>

            <p>Please note this is not the same project as <a href="http://brogue.roguelikelike.com/" target="_blank" rel="noopener noreferrer">web-brogue</a>,
              which is a cloud-based service, stores files in the cloud, and allows visitors to watch players and past recordings.
              BrogueJS is fully local to your browser and no information is sent to the server,
              files have to be downloaded using the file manager before sharing.</p>
          </div>
          <div id="file-manager" class="floating-div">
            <div id="file-mgr-nav">
              <div id="file-mgr-title">
                <img id="file-mgr-close" src="close.svg"/>
                <img id="upload" src="upload.svg"/>
                <span class="item-text">File Manager - upload, download, or delete save files and recordings</span>
              </div>
              <div id="file-mgr-upload" class="list-item">
                <hr/><span class="item-text"><input type="file" id="file-input" accept=".broguerec,.broguesave"/></span>
              </div>
              <hr/>
            </div>
            <div id="file-list"></div>
          </div>
        </div>
        <img id="escape" src="esc-button.png" />
        <img id="dirpad" src="direction-pad.svg" />
        <canvas id="game-canvas"></canvas>
      </div>
      {{{ SCRIPT }}}
    </body>
</html>
