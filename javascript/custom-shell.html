<!--

  BrogueJS (https://github.com/freethenation)

  @freethenation (Richard Klafter, 2019)
  @lachesis      (Eric Swanson,    2019)
  @brturn        (Bryan Turner,    2026)

  Copyright (C) 2019 Richard Klafter

     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Affero General Public License for more details.

     You should have received a copy of the GNU Affero General Public License
     along with this program.  If not, see <http://www.gnu.org/licenses/>.

-->

<html>
  <head>
    <link rel="apple-touch-icon" type="image/png" sizes="256x256" href="brogue-icon.png">
    <link rel="icon" type="image/png" sizes="256x256" href="brogue-icon.png">

    <!-- Various favicon formats -->
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="icon" type="image/vnd.microsoft.icon" href="favicon.ico">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" href="favicon.ico">
    <link rel="icon" type="image/png" href="brogue-icon.png">
    <!-- <link rel="icon" type="image/svg+xml" href="https://example.com/image.svg"> -->

    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <style>
      html, body {
        margin: 1;
        padding: 1;
        height: 100vh; /* Viewport height */
        background: #111111;
        color: #888888;
        background-attachment: fixed;
        overflow: hidden;
      }
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      #content {
        width: 100%;
        height: 100%;
      }
      div {
        margin: 0;
        padding: 0;
      }
      body a {
          color: #888888;
      }
      body a:hover {
          color: #6666cb;
      }
      #game-canvas {
          object-fit: contain;
          flex-grow: 1;
          flex-shrink: 1;
          background: #111111;
          image-rendering: pixelated;
      }
      .nav-bar > div {
        margin: 2px;  /* file manager list item padding */
        background-color: #6666cb;
      }
      span {
        height: 100%;
      }
      .list-item {
        display: flex;
        align-items: center;
        height: 2em;
      }
      .item-text {
        display: flex;
        align-items: center;
        height: 100%;
        padding-left: 0.5em;
      }
      .floating-div {
          position: fixed;
          top: 2em;
          left: 10%;
          width: 40%;
          height: 30%;
          overflow-y: auto;
          background-color: #333333;
          border: 1px solid black;
          padding: 10px;
          z-index: -1000;
          color: white;
      }
      canvas {
        image-rendering: pixelated;
        touch-action: none;
      }
      #keyboard {
        background-color: #222222;
        padding: 0.25em 0.5em;
        border: 2px solid var(--input-border);
        border-radius: 4px;
        display: none;
      }
      #file-manager {
        display: flex;
        flex-direction: column;
        border: 2px solid var(--input-border);
        border-radius: 4px;
      }
      #file-mgr-title {
        display: flex;
        align-items: center;
      }
      #file-mgr-upload {
        display: none;
      }
      #file-input {
        background-color: #222222;
        padding: 0.25em 0.5em;
        border: 2px solid var(--input-border);
        border-radius: 4px;
      }
      img {
        background-color: #555555;
        padding: 0.1em 0.1em;
        border: 2px solid var(--input-border);
        border-radius: 4px;
        max-width: 1.5em;
        max-height: 1.5em;
        margin: 2px;
      }
      img:hover {
        background-color: #777777;
      }
      #project-info {
          position: absolute;
          top: -2.5em;
          right: 0;
          width: 11em;
          min-height: 3em;
          transition: top 0.5s ease;
          box-sizing: border-box;
          z-index: 500;

          background-color: #555555;
          padding: 0.1em 0.1em;
          border: 2px solid var(--input-border);
          border-radius: 4px;
          margin: 2px;
      }
      #project-info.open {
          top: 0;
      }
      #brogue-js-info {
          position: fixed;
          top: 2em;
          left: 30%;
          width: 30%;
          height: 50%;
          overflow-y: auto;
          background-color: #333333;
          border: 1px solid black;
          padding: 10px;
          z-index: -1000;
          color: white;
      }
      #brogue-js-info a {
        color: #4c89c2
      }
    </style>
    <script type="text/javascript">

      // -------------------------------------------------
      // Constants
      // -------------------------------------------------

      const isMacOS = navigator.platform.match("Mac");
      const BROGUE_FONT = 'BrogueFont';
      const myFont = new FontFace(BROGUE_FONT, 'url(BrogueCE.ttf)');
      const MIN_EVENT_MS = 100;
      const FONT_HEIGHT_SCALE = 1.3;
      const STORE_NAME = "FILE_DATA";
      const BROGUE_PATH = "/brogue/";
      const CONSOLE_HEIGHT = 34;
      const CONSOLE_WIDTH = 100;
      const CELL_ASPECT_RATIO = 19/10;
      const eventTypes = {
          KEYSTROKE:0,
          MOUSE_UP:1,
          MOUSE_DOWN:2,
          RIGHT_MOUSE_DOWN:3,
          RIGHT_MOUSE_UP:4,
          MOUSE_ENTERED_CELL:5
      }

      // -------------------------------------------------
      // Globals
      // -------------------------------------------------

      let ctx, ctxWidth, ctxHeight;
      let cellWidth, cellHeight, canvas;
      let halfWidth, wallWidth, wallHeight, fontSize;
      let devicePixelRatio = window.devicePixelRatio || 1;
      let SUB_PIXEL_SCALE = devicePixelRatio;
      let FONT_NAME = "monospace";
      let lastMouseCell = [-1,-1];
      let lastMoveEvent = 0;
      const ongoingTouches = new Map(); // Mapping from the pointerId to the current finger position
      let firstTouch = null;
      let db = null;

      // -------------------------------------------------
      // Rendering
      // -------------------------------------------------

      const status = (str) => {
        document.getElementById("status").innerText = str;
      }

      const plotCharMap = (charMap, allChars) => {
        Object.values(charMap).forEach( plotChar => {
          let [char, x, y, fr, fg, fb, br, bg, bb] = plotChar;
          if (allChars !== null) allChars[(x<<8)+y] = plotChar;
          x = x*cellWidth;
          y = y*cellHeight;
          ctx.fillStyle = `rgb(${br/100*255|0}, ${bg/100*255|0}, ${bb/100*255|0})`;
          ctx.fillRect(x,y,cellWidth,cellHeight);
          ctx.fillStyle = `rgb(${fr/100*255|0}, ${fg/100*255|0}, ${fb/100*255|0})`;

          // Graphics mode tiles that look bad if there are gaps between them
          if ((char == 0x4051 || char == 0x4064 || char == 0x4041 || char == 0x4002)) {
            ctx.save(); // Save the current state
            const scaleX = cellWidth/wallWidth;
            const scaleY = cellHeight/wallHeight;
            const newX = (x + halfWidth)/scaleX; // Adjust location based on scale
            const newY = y/scaleY;
            ctx.scale(scaleX, scaleY);           // Stretch graphics to fit cell
            ctx.fillText(String.fromCharCode(char), newX, newY);
            ctx.restore();
          } else {
            ctx.fillText(String.fromCharCode(char), x + halfWidth, y);
          }
        });
      }

      const plotChars = () => {
        plotCharMap(window.plotChars, window.allChars);
        window.plotChars = {};
      }

      const plotAllChars = () => {
        plotCharMap(window.allChars, null);
      }

      // -------------------------------------------------
      // Mouse & Touch Events
      // -------------------------------------------------

      const getMousePos = (evt) => {
          const rect = canvas.getBoundingClientRect(); // abs. size of element
          const actualWidth = Math.min(rect.height*(canvas.width/canvas.height), rect.width)|0; //object-fit means the canvas ele will be scaled proportionally
          const actualHeight = Math.min(rect.width*(canvas.height/canvas.width), rect.height)|0; //so calculate actual width and height
          const scale = canvas.width/actualWidth;
          const offsetX = (rect.width-actualWidth)/2;
          const offsetY = (rect.height-actualHeight)/2;
          const x = (evt.clientX - rect.left) - offsetX;
          const y = (evt.clientY - rect.top) - offsetY;
          if (x<0 || x>actualWidth)  return null; // ignore if object-fit causes us to be outside actual canvas
          if (y<0 || y>actualHeight) return null; // ignore if object-fit causes us to be outside actual canvas
          const pix = [x*scale/devicePixelRatio, y*scale/devicePixelRatio]; // in pixels
          const pos = [(pix[0]/cellWidth)|0, (pix[1]/cellHeight)|0]; // in cells
          return pos;
      }

      const onMouseMove = (e) => {
        // Throttle mouse move events
        const now = Date.now();
        if (now < lastMoveEvent + MIN_EVENT_MS) return;
        lastMoveEvent = now;

        const pos = getMousePos(e);
        if (!pos) return;
        if (lastMouseCell[0]===pos[0] && lastMouseCell[1]===pos[1]) return; //cell did not change...bail
        lastMouseCell = pos;
        const EVENT = [ eventTypes.MOUSE_ENTERED_CELL, pos[0], pos[1], e.ctrlKey?1:0, e.shiftKey?1:0 ];
        window.keyOrMouseEvents.push(EVENT);
      }

      const onMouseDown = (e) => {
          const pos = getMousePos(e);
          if (!pos) return;
          const EVENT = [ e.button===0?eventTypes.MOUSE_DOWN:eventTypes.RIGHT_MOUSE_DOWN, pos[0], pos[1], e.ctrlKey?1:0, e.shiftKey?1:0 ];
          window.keyOrMouseEvents.push(EVENT);
          document.getElementById('project-info').classList.remove("open");
      }

      const onMouseUp = (e) => {
          const pos = getMousePos(e);
          if(!pos) return;
          const EVENT = [ e.button===0?eventTypes.MOUSE_UP:eventTypes.RIGHT_MOUSE_UP, pos[0], pos[1], e.ctrlKey?1:0, e.shiftKey?1:0 ];
          window.keyOrMouseEvents.push(EVENT);
      }

      const sendTouchAsMouseEvent = (event) => {
        if (event.touches.length > 1) return;
        if (event.type === "touchend" && event.touches.length > 0) return;

        // Make it look like a mouse event
        const touch = event.changedTouches[0];
        const e = {
          clientX: touch.clientX,
          clientY: touch.clientY,
          ctrlKey: event.ctrlKey,
          shiftKey: event.shiftKey,
          button: 0,
        }

        switch (event.type) {
          case "touchstart": return onMouseDown(e);
          case "touchmove":  return onMouseMove(e);
          case "touchend":   return onMouseUp(e);
          default: return;
        }
      }

      const handleTouchStart = (event) => {
        event.preventDefault();

        // Manage each simultaneous touch
        for (const changedTouch of event.changedTouches) {
          const touch = {
            pageX: changedTouch.pageX,
            pageY: changedTouch.pageY,
            id: changedTouch.identifier,
          };
          ongoingTouches.set(changedTouch.identifier, touch);

          // Record or update the first touch
          if (firstTouch === null || firstTouch.id === changedTouch.identifier) {
            firstTouch = touch;
            sendTouchAsMouseEvent(event);
          }
        }
      }

      const handleTouchMove = (event) => {
        event.preventDefault();

        for (const changedTouch of event.changedTouches) {
          const touch = ongoingTouches.get(changedTouch.identifier);
          if (!touch) {
            continue;
          }
          touch.pageX = changedTouch.pageX;
          touch.pageY = changedTouch.pageY;

          // Update firstTouch
          if (firstTouch !== null && firstTouch.id === changedTouch.identifier) {
            sendTouchAsMouseEvent(event);
          }
            // sendTouchAsMouseEvent(event);
        }
      }

      const handleTouchEnd = (event) => {
        event.preventDefault();

        for (const changedTouch of event.changedTouches) {
          if (!ongoingTouches.has(changedTouch.identifier)) {
            continue;
          }
          ongoingTouches.delete(changedTouch.identifier);

          // Update firstTouch
          if (firstTouch !== null && firstTouch.id === changedTouch.identifier) {
            sendTouchAsMouseEvent(event);
            firstTouch = null;
          }
        }

        // Failsafe, reset firstTouch when all touches end
        if (event.touches.length == 0) {
          firstTouch = null;
        }
      }

      const handleTouchCancel = (event) => {
        event.preventDefault();

        for (const changedTouch of event.changedTouches) {
          if (!ongoingTouches.has(changedTouch.identifier)) {
            continue;
          }
          ongoingTouches.delete(changedTouch.identifier);
          if (firstTouch !== null && firstTouch.id === changedTouch.identifier) {
            sendTouchAsMouseEvent(event);
            firstTouch = null;
          }
        }
      }

      // -------------------------------------------------
      // Key Events
      // -------------------------------------------------

      const KEY_MAP = {
          ArrowUp: 63232,
          ArrowLeft: 63234,
          ArrowDown: 63233,
          ArrowRight: 63235,
          PageUp:63276,
          PageDown:63277,
          Escape:27,
          Return:13,
          Enter:10,
          Delete:127,
          Backspace:127,
          Tab:9,
      }

      const allCtrlKeys = "hjklyubn78946123sxA"; // Keys that behave differently when a modifier is used
      const onKeydown = (e) => {
          // Override browser key bindings where possible
          const modkey = isMacOS ? e.metaKey : e.ctrlKey;
          if (   e.code == "NumpadDivide"
              || e.code == "Slash"
              || e.code == "Quote"
              || (modkey && allCtrlKeys.includes(e.key[0]))) {
            e.preventDefault();
          }
          const key = (e.key.length > 1) ? KEY_MAP[e.key] : e.key.charCodeAt(0);
          if (key === undefined) return;
          const EVENT = [eventTypes.KEYSTROKE, key, 0, e.ctrlKey?1:0, e.shiftKey?1:0];
          window.keyOrMouseEvents.push(EVENT);
      }

      // -------------------------------------------------
      // Initialization & Resizing
      // -------------------------------------------------

      const onRequestFullscreen = () => {
          const ele = document.getElementById('content');
          if (ele) ele.requestFullscreen();
      }

      const setupRetinaCanvas = (canvas) => {
          const ctx = canvas.getContext('2d');

          // Get the CSS-determined size of the canvas
          const rect = canvas.getBoundingClientRect();
          const cssWidth = rect.width;
          const cssHeight = rect.height;

          // Set the actual canvas buffer size to the high DPI dimensions
          canvas.width = cssWidth * devicePixelRatio;
          canvas.height = cssHeight * devicePixelRatio;

          // Scale the context so drawing operations use the CSS pixel coordinates
          ctx.scale(devicePixelRatio, devicePixelRatio);

          // Set the CSS dimensions back to the original intended size
          canvas.style.width = cssWidth + 'px';
          canvas.style.height = cssHeight + 'px';
          return ctx;
      }

      const roundTo = (num,sz) => {
        return Math.floor(num * sz) / sz;
      }

      const measureText = (cellAspect) => {
        const measure = ctx.measureText("\u{4051}")
        const width   = roundTo(measure.width, SUB_PIXEL_SCALE);
        const height  = roundTo((measure.actualBoundingBoxAscent + measure.actualBoundingBoxDescent), SUB_PIXEL_SCALE);

        // Record actual values for scaling later
        wallWidth  = width;
        wallHeight = height;

        // Use the measurements directly (aligns cell size with font sizes for clean rendering)
        cellWidth  = width;
        cellHeight = height;

        // Cells are too wide
        const aspect = cellHeight / cellWidth;
        if (aspect < 1) {
          cellWidth = height;
        } else if (aspect > cellAspect) { // Cells are too tall
          cellWidth = cellHeight/cellAspect;
        }
      }

      const findFontThatFits = (maxWidth, maxHeight) => {
        // Find proper font size
        const cellAspect = Math.max( 1, maxHeight / maxWidth );
        let size = 7;
        const FONT_MULT = 100;
        for (let i = 7*FONT_MULT; i <= 80*FONT_MULT; i++) { // 1/10 step in font sizes
            size = i/FONT_MULT;
            ctx.font = size+'px '+FONT_NAME;
            measureText(cellAspect);
            if (cellWidth > maxWidth || cellHeight > maxHeight) {
                size = (i-1)/FONT_MULT;
                ctx.font = size+'px '+FONT_NAME;
                measureText(cellAspect);
                break;
            }
        }
        return size;
      }

      const resizeCanvas = () => {
        const content = document.getElementById("content");
        canvas = document.getElementById('game-canvas');

        // We have to do a two-step dance when resizing:
        // - Set the content size to 100% to fill the screen
        // - Resize the canvas based on the content size
        // - Set the content size to be the size of the canvas so it centers properly
        content.style.width = "100%";
        content.style.height = "100%";

        const maxCellWidth  = roundTo(content.clientWidth  / (CONSOLE_WIDTH  + 0), SUB_PIXEL_SCALE);
        const maxCellHeight = roundTo(content.clientHeight / (CONSOLE_HEIGHT + 0), SUB_PIXEL_SCALE);  // Extra line of room at the bottom

        ctx = canvas.getContext("2d");
        ctx.textBaseline = "top";
        ctx.textAlign = "center";
        ctx.textRendering = 'pixelated';  // or 'geometricPrecision' or 'optimizeLegibility' (default)
        ctx.imageSmoothingEnabled = false;

        // Find proper font size
        fontSize = findFontThatFits(maxCellWidth, maxCellHeight);
        halfWidth = cellWidth/2;  // Optimization

        // Resize canvas
        ctxWidth = cellWidth * CONSOLE_WIDTH;
        ctxHeight = cellHeight * CONSOLE_HEIGHT;
        canvas.style.height = ctxHeight;
        canvas.style.width = ctxWidth;

        // Get context for the resized canvas
        ctx = setupRetinaCanvas(canvas);
        ctx.textBaseline = "top";
        ctx.textAlign = "center";
        ctx.fillStyle = 'white';
        ctx.textRendering = 'pixelated';  // or 'geometricPrecision' or 'optimizeLegibility' (default)
        ctx.imageSmoothingEnabled = false;
        ctx.font = fontSize+'px '+FONT_NAME;

        // Set the content tightly around the canvas so it centers properly
        content.style.width = ctxWidth;
        content.style.height = ctxHeight;

        // Redraw the canvas
        plotAllChars();
      }

      let animating = false;
      const startAnimation = () => {
        if (animating) return;  // Idempotent
        animating = true;
        window.requestAnimationFrame(() => {
            animating = false;
            plotChars();
            startAnimation();
          });
      }

      const initializeBrogueFrame = () => {
        resizeCanvas(FONT_NAME);

        // Register event handlers
        window.addEventListener('resize', () => resizeCanvas() );
        window.addEventListener('keydown', onKeydown, { capture: true });

        document.getElementById('request-fullscreen').addEventListener('click', onRequestFullscreen, false);
        document.getElementById('request-files').addEventListener('click', onRequestFiles, false);
        document.getElementById('file-input').addEventListener("change", handleFiles);
        document.getElementById('keyboard-icon').addEventListener("click", (ele) => { ele.target.value = ""; document.getElementById('keyboard').style.display = "block"; });
        document.getElementById('keyboard').addEventListener("blur", (ele) => { ele.target.value = ""; ele.target.style.display = "none"; document.getElementById('project-info').classList.remove("open"); });
        document.getElementById('file-mgr-close').addEventListener('click', () => { document.getElementById('file-manager').style.zIndex = -1000; }, false);
        document.getElementById('info').addEventListener('click', () => { document.getElementById('brogue-js-info').style.zIndex = 1000; }, false);
        document.getElementById('brogue-js-info').addEventListener('click', () => { document.getElementById('brogue-js-info').style.zIndex = -1000; }, false);
        document.getElementById('project-info').addEventListener('click', (ele) => { ele.target.classList.add("open"); }, false);
        document.getElementById('project-info').addEventListener('hover', (ele) => { ele.target.classList.add("open"); }, false);
        document.getElementById('upload').addEventListener('click', (ele) => { ele.target.style.display = "none"; document.getElementById('file-mgr-upload').style.display = "block"; }, false);
        document.getElementById('content').addEventListener("fullscreenchange", resizeCanvas );

        // Mouse & Touch Events
        canvas = document.getElementById('game-canvas');
        canvas.addEventListener('mousedown', onMouseDown, false);
        canvas.addEventListener('mouseup', onMouseUp, false);
        canvas.addEventListener('mousemove', onMouseMove, false);

        canvas.addEventListener('touchstart', handleTouchStart, false);
        canvas.addEventListener('touchend', handleTouchEnd, false);
        canvas.addEventListener('touchmove', handleTouchMove, false);
        canvas.addEventListener('touchcancel', handleTouchCancel, false);

        startAnimation();
      }

      // Page initialization
      window.keyOrMouseEvents = []; // Shared with C code for event queue
      window.plotChars = {}; // Shared with C code for graphics update queue
      window.allChars = {}; // For redrawing the window on resize, etc.

      // Load custom font
      document.addEventListener('DOMContentLoaded', function() {
        myFont.load().then(font => {
          document.fonts.add(font); // Add font to the document's font list
          FONT_NAME = BROGUE_FONT;
          initializeBrogueFrame();
        }).catch( e => {
          FONT_NAME = "monospace";
          initializeBrogueFrame();
        });
      });

      // -------------------------------------------------
      // File Manager
      // -------------------------------------------------

      const downloadFile = (uint8Array, filename, contentType) => {
        const blob = new Blob([uint8Array], { type: contentType });
        const exportUrl = URL.createObjectURL(blob);
        const a = document.createElement("a");
        document.body.appendChild(a); // Append link to body to ensure it's clickable in all browsers

        a.href = exportUrl;
        a.download = filename; // The 'download' attribute suggests a filename
        a.target = "_self"; // Open in the same tab
        a.click();

        document.body.removeChild(a);
        URL.revokeObjectURL(exportUrl);
      }

      const requestFileForDownload = (fileName) => {
        const transaction = db.transaction([STORE_NAME], "readonly");
        const objectStore = transaction.objectStore(STORE_NAME);
        const request = objectStore.get(BROGUE_PATH+fileName);
        request.onerror = (event) => {
          // Handle errors!
        };
        request.onsuccess = (event) => {
          downloadFile(request.result.contents, fileName, "text/plain"); 
        };
      }

      const requestDeleteFile = (fileName, ele) => {
        const transaction = db.transaction([STORE_NAME], "readwrite");
        const objectStore = transaction.objectStore(STORE_NAME);
        const request = objectStore.delete(BROGUE_PATH+fileName);
        request.onerror = (event) => {
          // Handle errors!
        };
        request.onsuccess = (event) => {
          ele.parentNode.removeChild(ele);
        };
      }

      const requestWriteFile = (fileName, fileData) => {
        const transaction = db.transaction([STORE_NAME], "readwrite");
        const objectStore = transaction.objectStore(STORE_NAME);

        const newFile = {
          contents: new Uint8Array(fileData),
          mode: 0o100666,
          timestamp: new Date(),
        };
        const request = objectStore.add(newFile, BROGUE_PATH+fileName);
        request.onsuccess = (event) => {
          console.log("Data added successfully", event.target.result);
          const FILES = document.getElementById("files");
          addFileListItem(FILES,fileName);
          document.getElementById("file-mgr-upload").innerHTML = "<hr/>Reload page to make this file visible to BrogueJS.";
        };
        request.onerror = (event) => {
          document.getElementById("file-mgr-upload").innerHTML = "<hr/>ERROR - " + event.target.error;
        };
      }

      const addFileListItem = (FILES, fileName) => {
        fileName = fileName.replaceAll(BROGUE_PATH,"");
        const a = document.createElement("div");
        a.className = "list-item";

        const del = document.createElement("img");
        del.src = "delete.svg";
        del.className = "delete";
        del.addEventListener("click",() => requestDeleteFile(fileName, a));
        a.appendChild(del)

        const save = document.createElement("img");
        save.src = "download.svg";
        save.className = "download";
        save.addEventListener("click",() => requestFileForDownload(fileName));
        a.appendChild(save);

        const txt = document.createElement("span");
        txt.className = "item-text";
        txt.textContent = fileName;
        a.appendChild(txt)
        FILES.appendChild(a); // Append link to body to ensure it's clickable in all browsers
      }

      const listAllObjects = () => {
        const transaction = db.transaction([STORE_NAME], "readonly");
        const objectStore = transaction.objectStore(STORE_NAME);
        const allKeysReq = objectStore.getAllKeys();
        allKeysReq.onsuccess = function(event) {
          const allKeys = event.target.result;
          const FILES = document.getElementById("files");
          FILES.innerHTML = ""; // Delete existing file list
          allKeys.forEach(key => {
            addFileListItem(FILES, key);
          });
        };

        allKeysReq.onerror = function(event) {
          console.error("Error retrieving all objects:", event.target.error);
        };

        // Optional: monitor the transaction completion
        transaction.oncomplete = function() {
          console.log("Transaction completed.");
        };
      }

      // IndexedDB
      const readDatabase = () => {
        // Let us open our database
        const request = window.indexedDB.open("/brogue");
        request.onerror = (event) => {
          console.error("Why didn't you allow my web app to use IndexedDB?!");
        };
        request.onsuccess = (event) => {
          db = event.target.result;
          db.onerror = (event) => {
            // Generic error handler for all errors targeted at this database's requests!
            console.error(`Database error: ${event.target.error?.message}`);
          };

          listAllObjects();
        };
      }

      const handleFiles = (event) => {
        const selectedFiles = event.target.files; // This is a FileList object

        if (selectedFiles && selectedFiles.length > 0) {
          const firstFile = selectedFiles[0];
          const reader = new FileReader();

          // Define what to do when the file is loaded
          reader.onload = function(event) {
            const fileContent = event.target.result;
            console.log('File content (as text):', fileContent);
            requestWriteFile(firstFile.name, fileContent);
          };

          // Read the file content
          reader.readAsArrayBuffer(firstFile);
        }
      }

      const onRequestFiles = () => {
          readDatabase();
          document.getElementById('file-manager').style.zIndex = 1000;
      }

      // -------------------------------------------------
      // Brogue Weekly Contest Seed
      // -------------------------------------------------

      const getMostRecentTuesday = () => {
        const today = new Date();
        const todayDayOfWeek = today.getDay(); // 0 (Sunday) to 6 (Saturday)
        const TUESDAY_DAY_OF_WEEK = 2; // Tuesday is 2

        // Calculate the difference in days.
        // The expression handles cases where today is Tuesday (diff is 0) or earlier in the week than Tuesday.
        const daysToSubtract = (todayDayOfWeek - TUESDAY_DAY_OF_WEEK + 7) % 7;
        const mostRecentTuesday = new Date(today);
        mostRecentTuesday.setDate(today.getDate() - daysToSubtract);

        // Get year, month, and day components
        const year = mostRecentTuesday.getFullYear();
        const month = (mostRecentTuesday.getMonth() + 1).toString().padStart(2, '0'); // Months are 0-indexed
        const day = mostRecentTuesday.getDate().toString().padStart(2, '0');
        return `${year}${month}${day}`;
      }
    </script>
  </head>
    <body oncontextmenu="return false;">
      <div id="content">
        <div id="nav-bar">
          <div id="project-info">
            <a href="#" id="request-fullscreen" title="Fulscreen"><img src="fullscreen.svg"/></a>
            <a href="#" id="request-files" title="File manager"><img src="files.svg"/></a>
            <img id="keyboard-icon" src="keyboard.svg" title="Open keyboard (for tablets)"/>
            <img id="info" src="info.svg" title="About BrogueJS"/>
            <a href="https://github.com/brturn/BrogueCE/issues" target="_blank" rel="noopener noreferrer" title="Report an issue"><img src="bugs.svg"/></a>
            <div><input type="text" id="keyboard" size="8" placeholder="Keyboard"/></div>
          </div>
          <div id="brogue-js-info">
            <img src="close.svg"/> <b>BrogueJS - Brogue in the browser!</b>
            <p><a href="https://github.com/brturn" target="_blank" rel="noopener noreferrer">Bryan Turner, 2026</a></p>

            <p>Please report any issues with this beta-test version to <a href="https://github.com/brturn/BrogueCE/issues">Bryan's issues list</a>.</p>

            <p>This is an updated and improved version of the original <a href="https://github.com/freethenation/broguejs" target="_blank" rel="noopener noreferrer">BrogueJS</a>,
              full credit goes to <a href="https://github.com/freethenation" target="_blank" rel="noopener noreferrer">Richard Klafter</a>
              and <a href="https://github.com/lachesis" target="_blank" rel="noopener noreferrer">Eric Swanson</a>.</p>

            <p>This version of Brogue is based on <a href="https://github.com/tmewett/BrogueCE" target="_blank" rel="noopener noreferrer">BrogueCE</a> (community edition),
              led by <a href="https://github.com/tmewett" target="_blank" rel="noopener noreferrer">Tom Mewett</a>.</p>

            <p>Brogue was created by <a href="http://sites.google.com/site/broguegame/" target="_blank" rel="noopener noreferrer">Brian Walker</a>.</p>

            <p>Graphic tiles are from the iOS port, <a href="https://github.com/btaylor84/iBrogueCE" target="_blank" rel="noopener noreferrer">iBrogueCE</a>,
              credit goes to <a href="https://github.com/sethhoward" target="_blank" rel="noopener noreferrer">Seth Howard</a>
              and <a href="https://github.com/btaylor84" target="_blank" rel="noopener noreferrer">Robert Taylor</a>.</p>

            <p>Improvements include:</p>
            <ul>
            <li>Updated to BrogueCE v1.15.1</li>
            <li>Uses the same font and graphics as the iOS port</li>
            <li>Supports high-dpi (retina) displays</li>
            <li>Sharp graphics, no image stretching</li>
            <li>Touch support for tablets (tested on iPad and iPhone)</li>
            <li>File manager for uploading, downloading, and deleting the save games and recordings</li>
            <li>Files are compatible with other BrogueCE platforms, so you can move files between devices to continue the adventure</li>
            <li>URL parameters supported for seed, graphics, mode, etc.  Allowing easy bookmarking and sharing experiences</li>
            <li>Keyboard request for tablet support</li>
            </ul>

            <p>BrogueJS has been tested working on:</p>
            <ul>
            <li>MacBook Pro M4, Mac OS 26.2: Safari, Firefox, Chrome</li>
            <li>iPad Pro Gen 3, iOS 26.3, Safari</li>
            <li>iPhone 14 Pro, iOS 26.2, Safari</li>
            </ul>

            <p>Please note this is not the same project as <a href="http://brogue.roguelikelike.com/" target="_blank" rel="noopener noreferrer">web-brogue</a>,
              which is a cloud-based service, stores files in the cloud, and allows visitors to watch players and past recordings.
              BrogueJS is fully local to your browser and no information is sent to the server,
              files have to be downloaded using the file manager before sharing.</p>
          </div>
          <div id="file-manager" class="floating-div">
            <div id="file-mgr-nav">
              <div id="file-mgr-title">
                <img id="file-mgr-close" src="close.svg"/>
                <img id="upload" src="upload.svg"/>
                <span class="item-text">File Manager - upload, download, or delete save files and recordings</span>
              </div>
              <div id="file-mgr-upload" class="list-item">
                <hr/><span class="item-text"><input type="file" id="file-input" accept=".broguerec,.broguesave"/></span>
              </div>
              <hr/>
            </div>
            <div id="files"></div>
          </div>
        </div>
        <!-- <div class="canvas-container"> -->
        <canvas id="game-canvas"></canvas>
        <!-- </div> -->
        <!-- <div id="status"></div> -->
      </div>
      {{{ SCRIPT }}}
    </body>
</html>
